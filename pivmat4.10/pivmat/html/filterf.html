<html><head><title>filterf (PIVMat Toolbox)</title>
<!-- Help file for filterf.m generated by makehtmldoc 1.22, 21-Mar-2018 23:52:48 -->
<!-- makehtmldoc (F. Moisy, 2005-2006), see http://www.fast.u-psud.fr/~moisy/ml/ -->
 
<link rel=stylesheet href="docstyle1.css" type="text/css">
</head>
<body bgcolor=#ffffff>
<table width="100%" border=0 cellpadding=0 cellspacing=0><tr><td valign=baseline bgcolor="#e7ebf7"><b>PIVMat Function Reference</b></td><td valign=baseline bgcolor="#e7ebf7" align=right><a href="extractf.html"><b>&lt;&lt; Prev</b></a>&nbsp;|&nbsp;<a href="flipf.html"><b>Next &gt;&gt;</b></a>&nbsp;</td></tr></table>
<font size=+3 color="#990000">filterf</font><br>
Apply a spatial filter to a vector/scalar field.<br>
<br>
 
<font size=+1 color="#990000"><b>Description</b></font>
<code><pre>
FF = <b>filterf</b>(F,FSIZE) applies a spatial filtering of the vector/scalar 
field(s) F by computing its 2D convolution with a Gaussian kernel of 
width FSIZE (expressed in mesh units).  If not specified, FSIZE=1 is 
taken by default. This operation filters out structures of size 
typically smaller than FSIZE (low-pass filter). The Gaussian kernel is 
defined as: 
 
   G(X,Y) = exp ( -(X^2+Y^2)/(2*FSIZE^2) ) 
 
The kernel is defined in a square domain of size 1+2*CEIL(3.5*FSIZE) 
(i.e., for FSIZE=1, it is defined over a 9x9 matrix). The convolution 
is performed using Matlab's CONV2 function. 
 
FF = <b>filterf</b>(F,FSIZE,KERNEL) specifies the kernel G(X,Y): 
      'gauss':   gaussian kernel (by default) 
      'flat':    flat (or top-hat) kernel, G = ONES(FSIZE,FSIZE) 
                 (FSIZE must be an even integer) 
      'igauss':  derivative of the integrated gaussian (minimized 
                 discretisation effects for small FSIZE). 
 
The size of the filtered field is smaller than the original field, to 
avoid boundary effects (the convolution is done by CONV2 with the 
option 'valid'). If you prefer to keep the whole field, use 
<b>filterf</b>(F,FSIZE,KERNEL,'same') 
 
Note : If there are missing data in the field, it is better to first 
interpolate the data. See <a href="interpf.html">interpf</a>. 
 
If FSIZE is an array, applies each element of FSIZE over each element 
of F (one must have LENGTH(FSIZE)=LENGTH(F)). 
 
If no output argument, the result is displayed by <a href="showf.html">showf</a>. 
 
</pre>
<font size=+1 color="#990000"><b>Examples</b></font>
<pre>
 
   v = loadvec('*.vc7'); 
   showf(<b>filterf</b>(v)); 
   showf(<b>filterf</b>(v,2,'flat')); 
   showf(<b>filterf</b>(vec2scal(v,'rot'),2)); 
 
</pre>
<font size=+1 color="#990000"><b>See Also</b></font>
<pre>
<a href="showf.html">showf</a>, <a href="medianf.html">medianf</a>, <a href="bwfilterf.html">bwfilterf</a>, <a href="addnoisef.html">addnoisef</a>, <a href="interpf.html">interpf</a>, 
GAUSSMAT, CONV2, <a href="tempfilterf.html">tempfilterf</a>. 
Published output in the Help browser 
   showdemo <b>filterf</b> 
 
</pre></code>
 
<br>
<table width="100%" border=0 cellspacing=0 bgcolor="#e7ebf7"><tr><td>&nbsp;<a href="extractf.html"><b>Previous: extractf</b></a></td><td align=right><a href="flipf.html"><b>Next: flipf</b></a>&nbsp;</td></tr></table><br>
2005-2017 <a href="pivmat.html">PIVMat Toolbox 4.10</a><br>
<br>
</body></html>
